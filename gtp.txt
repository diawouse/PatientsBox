public static Dataset<Row> processData(Map<String, Dataset<Row>> mapInputDatasets) throws Exception {
    LOGGER.info("Start processData");

    List<HashMap<String, String>> listAno = new ArrayList<>();

    Dataset<Row> eaicEvtDs = Utils.loadMaxParamAndFilterFlAct(
            mapInputDatasets.get(UsageRSRG.CATALOG_RSRG.J6_TR_EAI_CDC_EVT_TABLE_NAME),
            UsageRSRG.FIELD_LIST_KEYS_EVT,
            UsageRSRG.J6_TR_EAI_CDC_EVT.DT_MAJ_PAR, true);

    Dataset<Row> vadZoDs = mapInputDatasets.get(UsageEAIC.CATALOG_EAIC.J6_TA_EAI_CDC_VAD_TABLE_NAME);
    Dataset<Row> j6TsEaic = mapInputDatasets.get(UsageEAIC.CATALOG_EAIC.J6_TS_EAI_CDC_TABLE_NAME);

    Timestamp lastStep2ExecutionDate = TrackingUtils.getDateLastExecProcess(
            j6TsEaic, GeneralConstants.PROCESS_NUMBER.J6_TA_EAI_CDC_VAD);

    Dataset<Row> vadZbDs = Utils.filterDataSourceForUsage(
            mapInputDatasets.get(SourceRSRG.CATALOG_RSRG.DD_TA_EAI_CDC_VAD_TABLE_NAME), lastStep2ExecutionDate);
    vadZbDs = Utils.loadLastMaxVersion(vadZbDs, UsageEAIC.J6_TA_EAI_CDC_VAD.KEYS_VAD, UsageEAIC.J6_TA_EAI_CDC_VAD.ING_TMS_INGESTION);

    TrackingUtils.writeTrackInfo(vadZbDs, GeneralConstants.EVT_NUMBER.LECTURE, 
            UsageEAIC.CATALOG_EAIC.J6_TA_EAI_CDC_VAD_TABLE_NAME, GeneralConstants.PROCESS_NUMBER.J6_TA_EAI_CDC_VAD);

    if (Utils.isDatasetEmpty(vadZbDs)) {
        logAndTrackError(eaicEvtDs, VAD_01, "La table source est vide.", listAno);
        return null;
    }

    validateDatasetColumns(vadZbDs, eaicEvtDs, listAno);

    if (!Utils.isDatasetEmpty(vadZbDs) && !Utils.isDatasetEmpty(vadZoDs)) {
        validateDatesAndVersions(vadZbDs, vadZoDs, eaicEvtDs, listAno);
    }

    if (listAno.isEmpty()) {
        TrackingUtils.writeTrackInfo(vadZbDs, GeneralConstants.EVT_NUMBER.ECRITURE, 
                UsageEAIC.CATALOG_EAIC.J6_TA_EAI_CDC_VAD_TABLE_NAME, GeneralConstants.PROCESS_NUMBER.J6_TA_EAI_CDC_VAD);
        LOGGER.info("End processData");
        return vadZbDs;
    } else {
        trackBlockingIssues(listAno);
        LOGGER.info("End processData");
        return null;
    }
}

private static void validateDatasetColumns(Dataset<Row> vadZbDs, Dataset<Row> eaicEvtDs, List<HashMap<String, String>> listAno) {
    checkAndAddAnomaly(vadZbDs, eaicEvtDs, listAno, 
            col(UsageEAIC.J6_TA_EAI_CDC_VAD.CD_VAD).isin("OK", "KO").not(), VAD_02);

    checkAndAddAnomaly(vadZbDs, eaicEvtDs, listAno, 
            col(UsageEAIC.J6_TA_EAI_CDC_VAD.NO_VER_PAR).equalTo(EMPTY_STRING).or(col(UsageEAIC.J6_TA_EAI_CDC_VAD.NO_VER_PAR).isNull()), VAD_03);

    checkAndAddAnomaly(vadZbDs, eaicEvtDs, listAno, 
            col(UsageEAIC.J6_TA_EAI_CDC_VAD.DT_MAJ_PAR).equalTo(EMPTY_STRING).or(col(UsageEAIC.J6_TA_EAI_CDC_VAD.DT_MAJ_PAR).isNull()), VAD_04);
}

private static void validateDatesAndVersions(Dataset<Row> vadZbDs, Dataset<Row> vadZoDs, Dataset<Row> eaicEvtDs, List<HashMap<String, String>> listAno) {
    Date dateZb = vadZbDs.select(col(UsageEAIC.J6_TA_EAI_CDC_VAD.DT_MAJ_PAR)).first().getDate(0);
    Date dateZo = vadZoDs.select(max(col(UsageEAIC.J6_TA_EAI_CDC_VAD.DT_MAJ_PAR))).first().getDate(0);

    if (dateZb != null && dateZo.after(dateZb)) {
        addAnomaly(eaicEvtDs, listAno, VAD_05);
    } else if (dateZb == null) {
        addAnomaly(eaicEvtDs, listAno, VAD_05);
    }

    int noVerParZb = vadZbDs.withColumn("no_ver",
            when(col(UsageEAIC.J6_TA_EAI_CDC_VAD.NO_VER_PAR).isNull(), lit(-1))
                    .otherwise(col(UsageEAIC.J6_TA_EAI_CDC_VAD.NO_VER_PAR)))
            .select("no_ver").first().getInt(0);

    int noVerParZo = vadZoDs.select(UsageEAIC.J6_TA_EAI_CDC_VAD.NO_VER_PAR).first().getInt(0);

    if (noVerParZb < noVerParZo) {
        addAnomaly(eaicEvtDs, listAno, VAD_06);
    } else if (noVerParZb == noVerParZo) {
        addAnomaly(eaicEvtDs, listAno, VAD_07);
    }
}

private static void checkAndAddAnomaly(Dataset<Row> dataset, Dataset<Row> eaicEvtDs, List<HashMap<String, String>> listAno, Column condition, String anomalyCode) {
    if (dataset.filter(condition).limit(1).count() != 0) {
        addAnomaly(eaicEvtDs, listAno, anomalyCode);
    }
}

private static void addAnomaly(Dataset<Row> eaicEvtDs, List<HashMap<String, String>> listAno, String anomalyCode) {
    HashMap<String, String> mapAno = new HashMap<>();
    mapAno.put(Tracking.LL_ANO, Utils.getDescAno(eaicEvtDs, anomalyCode));
    mapAno.put(Tracking.CD_ANO, anomalyCode);
    listAno.add(mapAno);
}

private static void logAndTrackError(Dataset<Row> eaicEvtDs, String anomalyCode, String errorMessage, List<HashMap<String, String>> listAno) {
    LOGGER.error(errorMessage);
    addAnomaly(eaicEvtDs, listAno, anomalyCode);
    Tracking.trackInfo(GeneralConstants.PROCESS_NUMBER.J6_TA_EAI_CDC_VAD, GeneralConstants.EVT_NUMBER.CONTROLE, listAno.get(0));
}

private static void trackBlockingIssues(List<HashMap<String, String>> listAno) {
    for (HashMap<String, String> ano : listAno) {
        Tracking.trackInfo(GeneralConstants.PROCESS_NUMBER.J6_TA_EAI_CDC_VAD, GeneralConstants.EVT_NUMBER.CONTROLE_BLOQUANT, ano);
    }
}
